# 理解对象

## 属性的类型

属性分为两种：数据属性和访问器属性

### 数据属性

数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入这个位置。数据属性由 4 个特性来描述它们的行为。

+ `[[Configurable]]`：表示属性是否可以通过 `delete` 删除并重新定义，是否可以修改它的特性，以及是否可以把它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 `true`。严格模式下如果该特性为 `false` 但是仍然去使用 `delete` 方法删除属性（其他效果类似），将会抛出错误。另外，一个属性被定义为不可配置后，将无法再变回可配置的了。
+ `[[Enumerable]]`：表示属性是否可以通过 `for-in` 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 `true`。
+ `[[Writable]]`：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都 `true`。注意，严格模式下修改只读属性将会抛出错误。
+ `[[Value]]`：表示属性实际的值。这个特性的默认值是 `undefined`。

如果想要修改属性的默认特性，就必须使用 `Object.defineProperty()` 方法，这个方法接收 3 个参数：对象、属性名称和描述符对象。在调用该方法时，前三个特性如果不指定，则默认为 false。

### 访问器属性

访问器属性包含下列 4 个特性：

+ `[[Configurable]]`：表示属性是否可以通过 `delete` 删除并重新定义，是否可以修改它的特性，以及是否可以把它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 `true`。
+ `[[Enumerable]]`：表示属性是否可以通过 `for-in` 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 `true`。
+ `[[Get]]`：获取函数，在读取属性时调用，默认值是 `undefined`。
+ `[[Set]]`：设置函数，在写入属性是调用，默认值是 `undefined`。

访问器属性是不能直接定义的，必须使用 `Object.defineProperty()`，下面是一个例子：

```js
let book = {
    year_: 2017, // year_ 中的下划线用来表示该属性并不希望在对象方法的外部被访问
    edition: 1
}
Object.defineProperty(book, "year", {
    get() {
        return this.year_
    }
    set(newValue) {
    	if (newValue > 2017) {
            this.year_ = newValue
            this.edition += newValue - 2017
        }
	}
})
book.year = 2018
console.log(book.edition) // 2
```

访问器属性的典型使用场景便是和上面一样，即设置一个属性值会导致一些其他变化发生。

获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只有一个设置函数的属性是不能读取的，非严格模式下读取会返回 `undefined`，严格模式下会抛出错误。

## 定义多个属性

`Object.defineProperties()` 方法可以通过多个描述符一次性定义多个属性，它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应，如：

```js
let book = {}
Object.defineProperties(book, {
    year_: {
        value: 2017
    },
    edition: {
        value: 1
    }
})
```

## 读取属性的特性

使用 `Object.getOwnPropertyDescriptor()` 方法可以获取指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于数据属性和访问器属性分别包含对应的特性作为属性。

ES 2017 新增了 `Object.getOwnPropertyDescriptors()` 方法，该方法实现会在每个自由属性上调用 `Object.getOwnPropertyDescriptor()` 并在一个新对象中返回它们。

## 合并对象

ES6 添加了 `Object.assign()` 方法，该方法接受一个目标对象和一个或多个源对象作为参数，然后将每个源对象中的可枚举属性和自有属性赋值道目标对象上。对于每个符合条件的属性，这个方法会使用源对象上的 `[[Get]]` 取得属性的值，然后使用目标对象上的 `[[Set]]` 设置属性的值。

`Object.assign()` 实际上是对每个源对象执行浅复制。

对于相同属性，后面的属性会覆盖掉前面的属性。

## 对象标识及相等判定

Object.is() 方法判断两个值是否为同一个值。该方法接收两个参数，即比较的值，返回布尔值表示是否相等。

如果满足以下条件则两个值相等:

- 都是 `undefined`
- 都是 `null`
- 都是 `true` 或 `false`
- 都是相同长度的字符串且相同字符按相同顺序排列
- 都是相同对象（意味着每个对象有同一个引用）
- 都是数字且
  - 都是 +0
  - 都是 -0
  - 都是 NaN
  - 或都是非零而且非 NaN 且为同一个值

与 === 运算不相同。 \=\=\=  运算符 (包括 == 运算符）将数字 -0 和 +0 视为相等 ，而将 Number.NaN 与 NaN 视为不相等。

## 增强的对象语法

### 属性值简写

在给对象添加变量的时候，经常会出现属性名与变量名是一样的，例如：

```js
let name = "Yucohny"
let person = {
    name: name
}
```

简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 ReferenceError。

```js
let name = "Yucohny"
let person = {
    name
}
```

### 可计算属性

如果想要使用变量值为属性，那么必须先声明对象，然后使用中括号语法来添加属性。即，不能在对象字面量中直接动态命名属性。

```js
const name = "Yucohny"
let person = {}
person[name] = 19
```

有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为表达式而不是字符串来求值：

```js
const nameKey = "name"
const ageKey = "age"
let count = 0
function makeUniqueKey(key) {
    return `${key}_{count++}`
}
let person = {
    [makeUniqueKey(nameKey)]: "Yucohny",
    [makeUniqueKey(ageKey)]: 19
}
```

## 对象解构

> 完整笔记可以参见 [解构赋值](./解构赋值.md)

# 实例对象与 new 命令

## 构造函数

面向对象编程首先需要生成对象。对象是单个实物的抽象，通常需要一个模板。

在 JS 中，这个模板就是构造函数。

构造函数就是一个普通的函数，但是有自己的特征和用法。

```js
var Vehicle = function () {
  this.price = 1000;
};
```

上面的代码中， Vehicle 就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。

构造函数的特点有两个。

- 函数体内部使用了 this 关键字，代表了所要生成的对象实例。
- 生成对象的时候，必须使用 new 命令。

## `new` 命令

### 基本用法

`new` 命令的作用就是执行构造函数，返回一个实例对象。

```js
var Vehicle = function () {
  this.price = 1000;
};

var v = new Vehicle();
v.price // 1000
```

如果需要传入参数，像一般的函数意义正常传入参数即可。

new 命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。

```js
// 推荐的写法
var v = new Vehicle();
// 不推荐的写法
var v = new Vehicle;
```

### 无 new 命令调用构造函数

在没有 new 命令的情况下调用构造函数，会使得构造函数变成了普通函数，并不会生成实例对象。此时的 this 代表全局对象。

为了保证构造函数必须与 new 命令一起使用，一个解决办法是，构造函数内部使用严格模式。严格模式下，一旦没有使用 new 命令，而直接调用构造函数就会报错。

另一个解决办法，构造函数内部判断是否使用 new 命令，如果发现没有使用，则直接返回一个实例对象：

```js
var Vehicle = function () {
  if (!(this instanceof Vehicle)) {
      return new Vehicle()
  }
  this.price = 1000;
};
```

### new 命令调用普通函数

如果对普通函数（内部没有使用 this 关键字的函数）使用 new 命令，会返回一个空对象（原理见下）。

### new 命令的原理

使用 new 命令时，它后面的函数依次执行下面的步骤。

1. 创建一个空对象，作为将要返回的对象实例。
2. 将这个空对象的原型，指向构造函数的 prototype 属性。
3. 将这个空对象赋值给函数内部的 this 关键字。
4. 开始执行构造函数内部的代码。

构造函数内部，this 指的是一个新生成的空对象（这个），所有针对`this`的操作，都会发生在这个空对象上。

如果构造函数内部有 return 语句，并且 return 后面跟着一个对象，new 命令会返回 return 语句指定的对象；否则，就会忽略 return 语句，返回 this 这个对象。

### new.target

函数内部可以使用`new.target`属性。如果当前函数是`new`命令调用，`new.target`指向当前函数，否则为`undefined`。

```js
function f() {
  console.log(new.target === f);
}

f() // false
new f() // true
```

使用这个属性，可以判断函数调用的时候，是否使用`new`命令。

```js
function f() {
  if (!new.target) {
    throw new Error('请使用 new 命令调用！');
  }
  // ...
}

f() // Uncaught Error: 请使用 new 命令调用！
```

## Object.create() 创建实例对象

构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用 Object.create() 方法。

> 创建实例对象还有原型模式，参加下面的笔记。

# this 关键字

## 含义

this 可以用在构造函数之中，表示实例对象。除此之外，this 还可以用在别的场合。但不管是什么场合，this 都有一个共同点：它总是返回一个对象。

简单说，this 就是属性或方法“当前”所在的对象。

由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即 this 的指向是可变的。

## 实质

JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。

```js
var obj = { foo:  5 };
```

上面的代码将一个对象赋值给变量 obj。JavaScript 引擎会先在内存里面，生成一个对象 { foo: 5 }，然后把这个对象的内存地址赋值给变量 obj。也就是说，变量 obj 是一个地址。后面如果要读取 obj.foo，引擎先从 obj 拿到内存地址，然后再从该地址读出原始的对象，返回它的 foo 属性。

原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的 foo 属性，实际上是以下面的形式保存的。

```json
{
  foo: {
    [[value]]: 5
    [[writable]]: true
    [[enumerable]]: true
    [[configurable]]: true
  }
}
```

注意，foo 属性的值保存在属性描述对象的 value 属性里面。

这样的结构是很清晰的，问题在于属性的值可能是一个函数。

```js
var obj = { foo: function () {} };
```

这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给 foo 属性的 value 属性。

```json
{
  foo: {
    [[value]]: 函数的地址
    ...
  }
}
```

由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境。所以，this 就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。

## 使用场合

### 全局环境

全局环境使用 this，它指的就是顶层对象 window。

```js
this === window // true

function f() {
  console.log(this === window);
}
f() // true
```

上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，this 就是指顶层对象 window。

### 构造函数

构造函数中的 this，指的是实例对象（原理参见上文）。

### 对象的方法

如果对象的方法里面包含 this，this 的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变 this 的指向。

## 注意

### 避免多层 this

### 避免数组处理方法中的 this

### 避免回调函数中的 this

## 绑定 this 的方法

### call()

用法如下：

```js
Object.call(obj, arg1, arg2, ...)
```

第一个参数 obj 作为函数上下文的对象（绑定 this 在这个参数环境下下）。

第二个参数 arg 开始的所有参数都是传给该方法的参数。

### apply()

用法如下：

```js
Object.apply(obj, [args])
```

第一个参数 obj 作为函数上下文的对象（绑定 this 在这个参数环境下下）。

> 如果设为 null 或 undefined，则等同于指定全局对象。

第二个参数 [args] 传入一个数组作为函数运行参数。

### bind()

用法如下：

```js
Object.bind(obj, arg1, arg2, ...)
```

第一个参数 obj 作为函数上下文的对象（绑定 this 在这个参数环境下下）。

第二个参数 arg 开始的所有参数都是传给该方法的参数。

bind() 与 call() 的不同之处在于，call() 是直接修改了函数原本的运行环境，而 bind() 是修改了运行环境后返回新的函数（原来的函数本质上没有修改）。
