# 变量提升

我们首先介绍一下变量提升。考虑下面语句：

```js
var age = 19
```

该语句实际上是分为了声明与赋值两个阶段：

```js
var age
age = 19
```

变量的声明与赋值如上，然后我们考虑一下函数的声明和赋值：

```js
function f() {}

var g = function() {}
```

第一个函数 `f` 的声明是完整的函数声明；而第二个函数是通过先声明变量 `g`，然后将函数赋值给 `g`。

变量提升，是指在 JavaScript 代码执⾏过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“⾏为”。变量被提升后，会给变量设置默认值 undefined。

因此，我们考虑以下情况，便能够理解的。

```js
console.log(age)
var age = 19
console.log(age)
// undefined
// 19
```

# JS 代码的执行过程

在理解「变量提升」后，直观上会认为变量与函数的声明，会在物理层面移动到代码的最前面。但是，这个描述并不准确。

实际上变量和函数声明在代码中的位置是不会改变的，而是在编译阶段被 JS 引擎放入内存中。

JS 的执行流程是先将一段 JS 代码进行编译，编译后再执行。

我们接下来模拟一遍执行流程。

首先书写一段 JS 代码：

```js
console.log(age)
var age = 19
console.log(age)
```

随后进入编译阶段：

```js
var age = undefined。
```

然后再进入执行阶段：

```js
console.log(age)
age = 19
console.log(age)
```

# 执行上下文

在上面的例子中，我们将一段 JS 代码经过编译后，将会生产两部分内容：执行上下文与可执行代码。

> 可以简单认为分别对应了编译阶段与执行阶段的内容。

执行上下文，本质上是 JS 执行一段代码时的运行环境。在执行上下文中存在一个变量环境的对象 Variable Environment，这个变量环境对象保存了变量提升的内容，比如我们声明的变量 `age` 就保存在该对象中。

前面提到了，当一段代码最终被执行时，会首先经过 JS 引擎编译，并生成执行上下文与可执行代码。那么我们就要考虑怎样的代码能进行编译并创建执行上下文。

一般而言，有下列三种情况：

1. 当 JS 执行全局代码的时候，会编译全局代码并创建全局执行上下文。在整个页面的生命周期中，全局上下文只存在一份。
2. 当调用一个函数的时候，函数体内的代码会被编译并创建函数执行上下文。一般情况下，函数执行结束之后，创建的函数执行上下文也会被销毁。
3. 当使用 `eval` 函数的时候，`eval` 的代码也会被编译并创建执行上下文。

