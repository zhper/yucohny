# var

使用 `var` 声明变量会自动将声明变量的这一步提升到当前最近作用域的顶部，这就是变量提升 hoist。

> 变量提升中「提升」的是变量声明。

除此之外，反复多次使用 `var` 声明同一个变量也没有问题：

```js
var age = 16
var age = 26
console.log(age)
```

# let

## 基本用法

let 命令用于声明变量，类似于 var，但是 let 所声明的变量只在 let 命令所在的代码块（作用域）内有效。

函数内部的变量 i 与 循环变量 i 不在同一个作用域，而是各自有各自的作用域。

## 不存在变量提升

如标题。

## 暂时性死区

只要块级作用域存在 let 命令，那么它所声明的变量就会「绑定」当前这个区域，从而不受外部影响。

```js
let tmp = 'abc';
if (true) {
    tmp = 'bcd';
    let  tmp;
}
```

上面代码中存在全局变量 tmp，但是块级作用域中又用 let 声明了一个局部变量 tmp，导致后者会直接绑定当前作用域，所以在 tmp 的声明前对 tmp 赋值就会报错。

ES6 明确规定，如果局部中存在 let 和 const 命令，则这个区域对这些命令生成的变量从一开始就形成了封闭作用域。即，在代码块中使用 let 命令声明变量前，这些变量都是不可用的。这在语法上称为「暂时性死区」（temporal dead zone，TDZ）

TDZ 的存在导致了 typeof 不再是一个绝对安全的操作。在 let 命令前对相关变量实行 typeof 操作不会返回 undefined，而是直接抛出错误 ReferenceError。

总之，TDZ 的本质是只要进入当前作用域，所要使用的变量就已经存在，但是不可获取，只有等到变量声明的那一行代码出现，才可以获取和使用该变量。

> ES6 规定暂时性死区和 let、const 语句不存在变量提升，主要是为了减少运行时的错误，防止在变量声明之前就使用这个变量，从而导致意料之外的行为。

## 不允许重复声明

let 命令不允许在相同作用域中重复声明同一个变量。

# 块级作用域

## 为什么需要块级作用域

+ 内层变量可能会覆盖外层变量
+ 用来计数的循环遍历泄露为全局变量

## ES6 的块级作用域

外层代码块不受内层代码块的影响，外层代码块也无法读取内存作用域的变量。

块级作用域的出现，使得立即执行函数 IIFE 不再那么必要（因为可以直接大括号构建作用域）。

## 块级作用域与函数声明

简言之，ES6 中的块级作用域与函数声明有以下规定：

+ 允许在块级作用域内声明函数
+ 函数声明类似于 var，即会提升到全局作用域或函数作用域的头部。
+ 同时，函数声明还会提升到所在块级作用域的头部。

> 注意，上述规定对 ES6 的浏览器实现有效，其他环境的实现不用遵守，仍然将块级组哟用于的函数声明当作 let 处理即可。

## do 表达式

原本的块级作用域是没有返回值的，而如果想要返回值，可以在块级作用域前加上 do，使之变为 do 表达式：

```js
let x = do {
    let t = add(1, 2) * mul(1, 2);
    return t;
}
```

# const

## 基本用法

声明一个常量，且必须立即初始化，后续无法修改值。作用域相关问题与 let 一致。

## 本质

const 实际上保证的不是变量的值无法改动，而是变量指向的那个**内存地址**无法改动。对于简单类型的数据，值就保存在变量指向的那个内存地址中，因此等同于常量。

但对于复合类型的数据（主要是对象和数组）而言，变量指向的内存地址保存的只是一个指针，此时 const 只是保证该指针是不变的，至于它指向的数据结构是否可变，则与 const 无关。

如果想要将对象和数组也完全「冻结」，我们可以在严格模式下使用 Object.freeze 方法：

```js
'use strict'
const foo = Object.freeze({})
```

除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数：

```js
var constantize = obj => {
    Object.freeze(obj);
    Object.keys(obj).forEach( (key, i) => {
        if (typeof obj[key] === 'object') {
            constantize(obj[key])
        }
    })
}
```

# 顶层对象的属性

顶层对象在浏览器环境中指的是 window 对象，在 Node 环境中指的是 global 对象。在 ES5 中，顶层对象的属性与全局变量是等价的。

ES6 为弥补当中存在的不足，同时保持兼容性，作出下列规定：

+ var 命令和 function 命令声明的全局变量仍然是顶层对象的属性
+ let、const、class 命令声明的全局变量不属于顶层对象的属性

# global 对象

简言之，很难找到一种方法可以在所有情况下都取到顶层对象。下列是两种勉强可以使用的方法：

+ 使用三目运算符嵌套进行判断
+ 书写函数进行判断

这两种方法本质上都只是粗暴的进行判断，但是并不高效也不优雅。

现在有一个提案，在语言标准的层面引入 global 作为顶层对象，即，在所有环境下，global 都是存在的，都可以拿到顶层对象。

# 声明风格与最佳实践

1. 不使用 var
2. const 有限，let 次之。