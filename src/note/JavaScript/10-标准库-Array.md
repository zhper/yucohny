# 构造函数

略

# Array.isArray()

Array.isArray 方法返回一个布尔值，表示参数是否为数组。它可以弥补 typeof 运算符的不足。

```js
var arr = [1, 2, 3];

typeof arr // "object"
Array.isArray(arr) // true
```

上面代码中，typeof 运算符只能显示数组的类型是 Object，而 Array.isArray 方法可以识别数组。

# 实例方法

## valueOf()，toString()

数组的 valueOf 方法返回数组本身。

数组的 toString 方法返回数组的字符串形式。

## push()，pop()

push 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。

pop 方法用于删除数组的最后一个元素，并返回该元素。对空数组使用 pop 方法，不会报错，而是返回 undefined。

## shift()，unshift()

shift() 方法用于删除数组的第一个元素，并返回该元素。

unshift() 方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。

## join()

join() 方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。如果数组成员是 undefined 或 null 或空位，会被转成空字符串。

## concat()

concat 方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。

除了数组作为参数，也接受其他类型的值作为参数，添加到目标数组尾部。如果数组成员包括对象，concat 方法返回当前数组的一个浅拷贝。

## reverse()

reverse 方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。

## slice()

slice() 方法用于提取目标数组的一部分，返回一个新数组，原数组不变。

```js
arr.slice(start, end);
```

它的第一个参数为起始位置（从0开始，会包括在返回的新数组之中），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。

### 将类似数组的对象转为真正的数组

```js
Array.prototype.slice.call({ 0: 'a', 1: 'b', length: 2 })
// ['a', 'b']

Array.prototype.slice.call(document.querySelectorAll("div"));
Array.prototype.slice.call(arguments);
```

上面代码的参数都不是数组，但是通过`call`方法，在它们上面调用`slice()`方法，就可以把它们转为真正的数组。

## splice()

splice() 方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。

```js
arr.splice(start, count, addElement1, addElement2, ...);
```

splice 的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。

如果只是单纯地插入元素，splice 方法的第二个参数可以设为 0。

```js
var a = [1, 1, 1];

a.splice(1, 0, 2) // []
a // [1, 2, 1, 1]
```

如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。

```js
var a = [1, 2, 3, 4];
a.splice(2) // [3, 4]
a // [1, 2]
```

## sort()

略。

## map()

map() 方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。该函数调用时，map() 方法向它传入三个参数：当前成员、当前位置和数组本身。

```js
[1, 2, 3].map(function(elem, index, arr) {
  return elem * index;
});
// [0, 2, 6]
```

上面代码中，map() 方法的回调函数有三个参数，elem 为当前成员的值，index 为当前成员的位置，arr 为原数组。

map() 方法还可以接受第二个参数，用来绑定回调函数内部的 this 变量：

```js
var arr = ['a', 'b', 'c'];

[1, 2].map(function (e) {
  return this[e];
}, arr)
// ['b', 'c']
```

如果数组有空位，map() 方法的回调函数在这个位置不会执行，会跳过数组的空位（但是不会跳过 undefined 和 null）。

## forEach()

forEach() 方法与 map() 方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach() 方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用 map() 方法，否则使用 forEach() 方法。

forEach() 的用法与 map() 方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。

注意，forEach() 方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，只能使用 for 循环。

## filter()

filter() 方法用于过滤数组成员，满足条件的成员组成一个新数组返回。

它的参数是一个函数，所有数组成员依次执行该函数，返回结果为 true 的成员组成一个新数组返回。该方法不会改变原数组。

filter() 方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。

filter() 方法还可以接受第二个参数，用来绑定参数函数内部的 this 变量。

## some()，every()

返回一个布尔值，表示判断数组成员是否符合某种条件。

它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。

some 方法是只要一个成员的返回值是 true，则整个 some 方法的返回值就是 true，否则返回 false。

## reduce()，reduceRight()

reduce() 方法和 reduceRight() 方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce() 是从左到右处理（从第一个成员到最后一个成员），reduceRight() 则是从右到左（从最后一个成员到第一个成员），其他完全一样。

reduce() 方法和 reduceRight() 方法的第一个参数都是一个函数。该函数接受以下四个参数。

1. 累积变量。第一次执行时，默认为数组的第一个成员；以后每次执行时，都是上一轮的返回值。
2. 当前变量。第一次执行时，默认为数组的第二个成员；以后每次执行时，都是下一个成员。
3. 当前位置。一个整数，表示第二个参数（当前变量）的位置，默认为`1`。
4. 原数组。

这四个参数之中，只有前两个是必须的，后两个则是可选的。

如果要对累积变量指定初值，可以把它放在 reduce() 方法和 reduceRight() 方法的第二个参数。

```js
[1, 2, 3, 4, 5].reduce(function (a, b) {
  return a + b;
}, 10);
```

## indexOf()， lastIndexOf()

略。

## 链式使用

略。

# 扩展运算符

扩展运算符 spread 是三个点 ...，如同 rest 参数的逆运算，将一个数组转化为用逗号分隔的参数序列。

## 替代数组的 apply 方法

如标题，显然。

## 应用

+ 合并数组

```js
arr1 = [1, 2]
arr2 = [3, 4]
arr3 = [5, 6]
console.log([0, ...arr1])
console.log([...arr1, ...arr2, ...arr3])
// [ 0, 1, 2 ]
// [ 1, 2, 3, 4, 5, 6 ]
```

+ 与解构赋值结合

```js
const [first, ...rest] = [1, 2, 3, 4, 5]
console.log(first)
console.log(rest)
// 1
// [ 2, 3, 4, 5 ]
```

> 如果将扩展运算符用于数组赋值，则只能将其放在参数的最后一位，否则报错。

+ 函数的返回值
+ 字符串

```js
console.log([...'Hello'])
// console.log([...'Hello'])
```

+ 实现 Iterator 接口的对象
+ Map 和 Set 结构、Generator 函数

# Array.from()
