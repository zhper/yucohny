# 数组的解构赋值

## 基本使用

如果解构不成功，变量的值等于 undefined。

如果是不完全解构，等号左边的模式匹配只匹配顺序下一部分等号右边的数组。

如果等号的右边不是可遍历结构，则会报错。（即等号右边的值或者对象是否具备 Iterator 接口）

Set 结构，也可以使用与数组类似的解构赋值。

## 默认值

解构赋值允许指定默认值。

ES6 内部使用 === 判断一个位置是否有值。所以，如果一个数组成员不严格等于 undefined，默认值是不会生效的。

如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到时才会求值。

# 对象的解构赋值

对象的解构与数组有一个重要的不同是：数组的元素是按照次序排列的，变量的取值是由它的位置决定；而对象的属性没有次序，变量必须与属性同名才能取到正确的值。

对象解构赋值的内部机制是先找到同名属性，然后再赋值给对应的变量。真正被赋值的是后者，而不是前者。

对象解构赋值默认值生效的条件是，对象的属性值严格等于 undefined。

由于数组是特殊的对象，因此可以对数组进行对象属性的解构。将数组的下标作为 key，本身的值作为 val 即可。

# 字符串的解构赋值

一般赋值与当作对象解构赋值，略。

# 数值和布尔值的解构赋值

如果等号的右边是数值和布尔值，则会先转化为对象。

```js
let {toString: s} = 123
console.log(s === Number.prototype.toString)
```

```js
let {toString: s} = true
console.log(s === Boolean.prototypew.toString)
```

上面的代码中，由于数值和布尔值的包装对象上都有 toString 属性，因此都可以取到值。

# 函数参数的解构赋值

类似，故省略。

# 圆括号问题

在解构赋值中如果出现了圆括号应该如何处理？ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。故有下列规则

## 不能使用圆括号的情况

1. 变量声明语句

   变量声明语句的模式中不能使用圆括号。

2. 函数参数

   函数参数也属于变量声明，因此不能使用圆括号。

3. 赋值语句的模式

   不能将全部的代码或者一部分代码放在圆括号之中，会报错。

## 可以使用圆括号的情况

可以使用圆括号的情况只有一种：赋值语句的非模式部分可以使用原括号。

# 解构赋值的用途

1. 交换变量的值

   ```js
   let x = 1, y = 2
   [x, y] = [y, x]
   ```

2. 从函数返回多个值

   函数只能返回一个值，如果要返回多个值，只能将它们放在数组或者对象中返回，从而可以使用解构赋值取出这些值。

3. 函数参数的定义

   解构赋值可以很方便地把一组参数与变量名对应起来。

   ```js
   function f([x, y, z]) {...}
   f([1, 2, 3])
   ```

   ```js
   funciton f({x, y, z}) {...}
   f({z: 3, y: 2, z: 1})
   ```

4. 提取 JSON 数据

   容易理解

5. 函数参数的默认值

   容易理解

6. 遍历 Map 结构

   任何部署了 Iterator 接口的对象都可以用 for ... of 循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值获取键名和键值非常方便。

   ```js
   var map = new Map()
   map.set({'a', 1})
   map.set({'b', 2})
   
   for (let [key, val] of map) {
       ...
   }
   ```

7. 输入模块的指定方法

   ```js
   const {Component} = require('react')
   ```

   
